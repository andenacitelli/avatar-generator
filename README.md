## Overview

Hey! I'm Anden Acitelli. This is my take-home project for my Akkio application.

I'm doing the Avatar generator project, where the goal is basically just to take an arbitrary string and turn it into a picture. I gather that it's basically supposed to be like a hash function, where small differences in input result in large differences in output, but it's still deterministic.

The page states that you should treat this as if you 

## Objectives

Here's my objectives / goals:

- **Symmetry looks good.** I can do this by mirroring everything at the end.
- **Continuity looks good.** I can do this by using a continuous color gradient. Something like Perlin noise should do the trick.

- **Should look roughly like a face.** This is not at all a strict guideline. Aiming for eyes and making it symmetrical should be enough.
- **Small input changes should result in large output changes.** I feel like everybody having a completely

## Technical Approach

Some important considerations that will probably influence things:

- Should basically be a hash function; small differences in input lead to large differences in output. I'll probably do this by hashing the initial value, then using the hash to generate the image.
- Favicons are generally continuous. You shouldn't have abrupt shifts. It should be a continuous color gradient of sorts.
- Should be discrete colors. Not a single color.

I'm thinking something like Conway's game of life could be cool. I've also done lots of work with Perlin Maps before (basically, continuous 2d noise) which could be really cool - the Notion page mentions libraries are permitted, so I'll probably go with this. Will probably generate three Perlin maps (one each for r/g/b), round them to the nearest ~16, and call it a day.

**Revisiting:** My end approach was to generate four Perlin maps, apply a discrete filter that resulted in the values either being 0 or 1 (instead of the continuous [-1, 1] range), then generating a random color for each map then applying that color wherever that map was 1.

## Technical Details Of Note

- I generate the image on the backend, then view it on the frontend. This is via Next.js's serverless API routes. This can very well be done on the frontend exclusively; I chose to use the backend route because `react-konva`, the usual go-to package for React-based Canvas manipulation, tends to not play too well with Next.js, and most CPU-intensive processes like that would usually be done on the backend anyway.
- **Tech Stack;** 
  - React used for UI display and b/c I'm used to it
  - Next.js (React metaframework) again used b/c I'm used to it, and because I like the flexibility of having backend route handlers bundled directly there if I need them
  - TypeScript used to minimize runtime errors
  - Notable Libraries: `mantine` for basic UI, `alea` for a provably better, seedable hash function for generating colors, `crypto` for sha256 hashing,  `simplex-noise` for Perlin noise map generation, `uuid` to generate a random seed value if none is provided (I could technically use a formal random library, but UUID is good enough, and there's like a one in a million chance any UUIDs generated by anyone anywhere on the planet in the next year will collide), `jest` for unit testing, `eslint` for pre-compilation type checking, `pretter` for low-config code style enforcement

## Future Work

I took about 2-2.5 hours to work on this. Maybe half an hour of that was setting up the template project, half an hour was writing comments and documentation, and the rest was general scaffolding, Jest tests with TypeScript, and so on.

If I had more time, here's some ways I'd improve on it:

1. **A blur filter.** I would basically set each pixel to the most prominent color present in the 10x10 box around this. This would get rid of little pockets of solo color that mess with the color, and just smooth things out in general.
2. **Generate an actual color palette with color theory behind it.** I did some googling around for JavaScript libraries for this, but was unable to find something good. Maybe a business idea for me; could just throw it on RapidAPI and call it a day :)
3. **A bit more thought towards the shape.** I have the smooth features and symmetricality of a face, but don't really have a ton of thought put towards an actual face.
4. **Break down the code a bit more.** For a more long-term project, I'd break the orchestration function I have going (`generateImage`) into smaller functions that are more easily testable.

Overall, I think I was able to get some impressive work done and produce a completely serviceable avatar generator. Could it be improved? Sure. But does it work decently well and was it done in a short amount of time? Also yes.

## Important Files

All code is inside `src`. Here's the important ones:

- `pages/index.tsx` - The main page. This is where the UI is.
- `pages/api/generate.ts` - The API endpoint that generates the avatar. This gets the image to the frontend by saving the generated image to the filesystem.
- `business/generateImage` - The main image generation function.

Tests are in `tests/`. They aren't very extensive, but they validate things minimally work and provide decent coverage.

## Install

I figured it would be cool to build an associated, basic UI with this as well, to make it easier to look at the actual icon.

To view:

- Clone the project
- Install npm if you don't have it yet; Node.js comes with npm
- Run `npm install` to install dependencies
- Run `npm run dev` to start up the local dev server
- Visit `localhost:3000` in your browser. Each time you refresh the page, a random icon will be generated. If this was more than a take-home project, I'd probably have a button automatically regenerate it, but this is sufficient.

## Test
Basic unit tests are present to check functions work correctly. Utility functions are tested fairly in-depth, and the main function for generating stuff just has one test to make sure it doesn't crash.

Run `npm run test` to run tests.

## Old Stuff

Everything below was from the template `create-next-app` below. Not for the take-home.

This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `pages/index.tsx`. The page auto-updates as you edit the file.

[API routes](https://nextjs.org/docs/api-routes/introduction) can be accessed on [http://localhost:3000/api/hello](http://localhost:3000/api/hello). This endpoint can be edited in `pages/api/generate.ts`.

The `pages/api` directory is mapped to `/api/*`. Files in this directory are treated as [API routes](https://nextjs.org/docs/api-routes/introduction) instead of React pages.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.
